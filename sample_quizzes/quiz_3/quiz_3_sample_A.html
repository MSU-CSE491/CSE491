<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiple Choice Quiz</title>
  <link rel="stylesheet" href="quiz_3_sample_A.css">
</head>
<body>

<form id="quizForm">
  <h1>Multiple Choice Quiz</h1>

  <!-- Question 20 -->
  <div class="question">
    <p><b>1.</b> When you create a unique pointer you can provide a function to run on deletion.  Why is this useful?</p>
    <div class="options"><label><input type="radio" name="q20" value="(A)">(A) You can use this to ensure that no other pointers are referring to this object before deleting it.</label></div>
    <div class="options"><label><input type="radio" name="q20" value="(B)">(B) You can have it perform additional actions to manage resources, such as closing files or releasing sockets.</label></div>
    <div class="options"><label><input type="radio" name="q20" value="(C)">(C) It is an excess feature in the interface that has little practical utility.</label></div>
    <div class="options"><label><input type="radio" name="q20" value="(D)">(D) You must do this to make sure to delete the associated pointer.</label></div>
  <div class="answer" data-question="q20"></div> <!-- Placeholder for answer --></div>

  <!-- Question 23 -->
  <div class="question">
    <p><b>2.</b> Which of the following is _NOT_ an instance of undefined behavior in C++?</p>
    <div class="options"><label><input type="radio" name="q23" value="(A)">(A) Dereferencing a null pointer</label></div>
    <div class="options"><label><input type="radio" name="q23" value="(B)">(B) Accessing an object after <code>free</code> has been called on it</label></div>
    <div class="options"><label><input type="radio" name="q23" value="(C)">(C) Having a <code>return</code> statement in a <code>void</code> function</label></div>
    <div class="options"><label><input type="radio" name="q23" value="(D)">(D) Accessing un-initialized variables</label></div>
    <div class="options"><label><input type="radio" name="q23" value="(E)">(E) Reading off the end of an <code>std::vector</code></label></div>
  <div class="answer" data-question="q23"></div> <!-- Placeholder for answer --></div>

  <!-- Question 13 -->
  <div class="question">
    <p><b>3.</b> Why should you use <code>std::make_unique</code> instead of <code>new</code> when constructing a <code>unique_ptr</code>?</p>
    <div class="options"><label><input type="radio" name="q13" value="(A)">(A) They are functionally identical and it doesn&apos;t matter.</label></div>
    <div class="options"><label><input type="radio" name="q13" value="(B)">(B) To delay object creation until first usage.</label></div>
    <div class="options"><label><input type="radio" name="q13" value="(C)">(C) To manually manage memory.</label></div>
    <div class="options"><label><input type="radio" name="q13" value="(D)">(D) To ensure exception safety and efficiency.</label></div>
  <div class="answer" data-question="q13"></div> <!-- Placeholder for answer --></div>

  <!-- Question 33 -->
  <div class="question">
    <p><b>4.</b> What is the advantage of a &quot;time-traveling&quot; debugger?</p>
    <div class="options"><label><input type="radio" name="q33" value="(A)">(A) They allow you to make temporary changes to debug your code that you can then rewind back to their original state.</label></div>
    <div class="options"><label><input type="radio" name="q33" value="(B)">(B) None.  Time-traveling debuggers are purely theoretical and do not exist yet.</label></div>
    <div class="options"><label><input type="radio" name="q33" value="(C)">(C) They allow you to trace back how variables got the values they currently have without needing to restart a run.</label></div>
    <div class="options"><label><input type="radio" name="q33" value="(D)">(D) The produce graphs of variable values over time to help you identify unexpected correlations.</label></div>
    <div class="options"><label><input type="radio" name="q33" value="(E)">(E) They work with git repositories to trace back when in time a bug was introduced to your code.</label></div>
  <div class="answer" data-question="q33"></div> <!-- Placeholder for answer --></div>

  <!-- Question 18 -->
  <div class="question">
    <p><b>5.</b> What happens when you run <code>std::move()</code> on a <code>unique_ptr</code> value?</p>
    <div class="options"><label><input type="radio" name="q18" value="(A)">(A) The <code>unique_ptr</code> is converted into a raw pointer, but otherwise unmodified. </label></div>
    <div class="options"><label><input type="radio" name="q18" value="(B)">(B) The pointed-to object is copied to a different position in memory and that new position is returned.</label></div>
    <div class="options"><label><input type="radio" name="q18" value="(C)">(C) The pointed-to object is moved to a specified position in memory and the <code>unique_ptr</code>&apos;s value is updated to this new position.</label></div>
    <div class="options"><label><input type="radio" name="q18" value="(D)">(D) The pointed-to memory stays where it is, but is marked as being allowed to be assigned (shifting ownership) to a different pointer.</label></div>
  <div class="answer" data-question="q18"></div> <!-- Placeholder for answer --></div>

  <!-- Question 2 -->
  <div class="question">
    <p><b>6.</b> For which of the following is <code>static_cast</code> NOT appropriate?</p>
    <div class="options"><label><input type="radio" name="q2" value="(A)">(A) Converting between numeric data types (e.g., int to float).</label></div>
    <div class="options"><label><input type="radio" name="q2" value="(B)">(B) Converting between unrelated pointer types.</label></div>
    <div class="options"><label><input type="radio" name="q2" value="(C)">(C) Upcasting (from derived to base).</label></div>
    <div class="options"><label><input type="radio" name="q2" value="(D)">(D) Downcasting (from base to derived) when you&apos;re certain of the object&apos;s actual type.</label></div>
  <div class="answer" data-question="q2"></div> <!-- Placeholder for answer --></div>

  <!-- Question 15 -->
  <div class="question">
    <p><b>7.</b> What happens when the only two shared_ptrs pointing to an object both go out of scope?</p>
    <div class="options"><label><input type="radio" name="q15" value="(A)">(A) Reference count goes to zero and the object is deleted.</label></div>
    <div class="options"><label><input type="radio" name="q15" value="(B)">(B) Reference count goes to 1 but the object remains.</label></div>
    <div class="options"><label><input type="radio" name="q15" value="(C)">(C) Undefined behavior occurs.</label></div>
    <div class="options"><label><input type="radio" name="q15" value="(D)">(D) The object is deleted twice.</label></div>
  <div class="answer" data-question="q15"></div> <!-- Placeholder for answer --></div>

  <!-- Question 10 -->
  <div class="question">
    <p><b>8.</b> Which of the following best describes the primary use of <code>std::forward</code>?</p>
    <div class="options"><label><input type="radio" name="q10" value="(A)">(A) To move ownership of resources.</label></div>
    <div class="options"><label><input type="radio" name="q10" value="(B)">(B) To cast values between unrelated types.</label></div>
    <div class="options"><label><input type="radio" name="q10" value="(C)">(C) To ensure that casing can only be done in one direction.</label></div>
    <div class="options"><label><input type="radio" name="q10" value="(D)">(D) To pass on arguments as they were provided to the calling function.</label></div>
  <div class="answer" data-question="q10"></div> <!-- Placeholder for answer --></div>

  <!-- Question 32 -->
  <div class="question">
    <p><b>9.</b> Which if the following is NOT a reason that assertions are helpful in your code?</p>
    <div class="options"><label><input type="radio" name="q32" value="(A)">(A) They can clearly identify that a problem exists before a regular crash or incorrect output occurs.</label></div>
    <div class="options"><label><input type="radio" name="q32" value="(B)">(B) They can be easily removed and thus have no negative impact on released code.</label></div>
    <div class="options"><label><input type="radio" name="q32" value="(C)">(C) They can be used to bring out-of-range function parameters back into range to restore code correctness.</label></div>
    <div class="options"><label><input type="radio" name="q32" value="(D)">(D) They will sometimes catch non-deterministic errors, helping you narrow down where they occurred.</label></div>
    <div class="options"><label><input type="radio" name="q32" value="(E)">(E) They interact well with debuggers, which help your trace back why an assertion failed.</label></div>
  <div class="answer" data-question="q32"></div> <!-- Placeholder for answer --></div>

  <!-- Question 31 -->
  <div class="question">
    <p><b>10.</b> Which of the following debugging techniques should typically be attempted only after the other techniques fail to help you resolve the issue?</p>
    <div class="options"><label><input type="radio" name="q31" value="(A)">(A) Add asserts to test pre- and post-conditions for functions that you expect to be involved.</label></div>
    <div class="options"><label><input type="radio" name="q31" value="(B)">(B) Add more related unit tests to understand the scope of your problem.</label></div>
    <div class="options"><label><input type="radio" name="q31" value="(C)">(C) Run your code through a debugger to see if it identifies the problem.</label></div>
    <div class="options"><label><input type="radio" name="q31" value="(D)">(D) Systematically remove (or comment out) sections of your program to find the minimal code that exhibits the problem.</label></div>
    <div class="options"><label><input type="radio" name="q31" value="(E)">(E) Fix all compiler warnings.</label></div>
  <div class="answer" data-question="q31"></div> <!-- Placeholder for answer --></div>

  <hr><p>
  Click <b>Check Answers</b> to identify any errors and try again.  Click <b>Show Answers</b> if you also want to know which answer is the correct one.
  </p>
  <button type="button" id="checkAnswersBtn">Check Answers</button>
  <button type="button" id="showAnswersBtn">Show Answers</button>
</form>
<div id="results"></div>
<script src="quiz_3_sample_A.js"></script>
</body>
</html>
