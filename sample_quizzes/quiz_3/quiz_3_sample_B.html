<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiple Choice Quiz</title>
  <link rel="stylesheet" href="quiz_3_sample_B.css">
</head>
<body>

<form id="quizForm">
  <h1>Multiple Choice Quiz</h1>

  <!-- Question 1 -->
  <div class="question">
    <p><b>1.</b> What happens if you try to use <code>dynamic_cast</code> to convert a pointer, but the cast fails?</p>
    <div class="options"><label><input type="radio" name="q1" value="(A)">(A) A null pointer is returned.</label></div>
    <div class="options"><label><input type="radio" name="q1" value="(B)">(B) It always succeeds.</label></div>
    <div class="options"><label><input type="radio" name="q1" value="(C)">(C) An exception is thrown.</label></div>
    <div class="options"><label><input type="radio" name="q1" value="(D)">(D) The program aborts.</label></div>
  <div class="answer" data-question="q1"></div> <!-- Placeholder for answer --></div>

  <!-- Question 13 -->
  <div class="question">
    <p><b>2.</b> Why should you use <code>std::make_unique</code> instead of <code>new</code> when constructing a <code>unique_ptr</code>?</p>
    <div class="options"><label><input type="radio" name="q13" value="(A)">(A) To ensure exception safety and efficiency.</label></div>
    <div class="options"><label><input type="radio" name="q13" value="(B)">(B) They are functionally identical and it doesn&apos;t matter.</label></div>
    <div class="options"><label><input type="radio" name="q13" value="(C)">(C) To manually manage memory.</label></div>
    <div class="options"><label><input type="radio" name="q13" value="(D)">(D) To delay object creation until first usage.</label></div>
  <div class="answer" data-question="q13"></div> <!-- Placeholder for answer --></div>

  <!-- Question 34 -->
  <div class="question">
    <p><b>3.</b> Which of the following is NOT a productive development practice for preventing bugs in your code?</p>
    <div class="options"><label><input type="radio" name="q34" value="(A)">(A) Comment out sections of code that you are unsure about and come back to them later.</label></div>
    <div class="options"><label><input type="radio" name="q34" value="(B)">(B) Add functionality in small sections of code at a time.</label></div>
    <div class="options"><label><input type="radio" name="q34" value="(C)">(C) Always verify that new functionality doesn&apos;t break previous tests.</label></div>
    <div class="options"><label><input type="radio" name="q34" value="(D)">(D) Add asserts to test pre-conditions and post-conditions in new functions.</label></div>
    <div class="options"><label><input type="radio" name="q34" value="(E)">(E) Create new test for each new increment in functionality.</label></div>
  <div class="answer" data-question="q34"></div> <!-- Placeholder for answer --></div>

  <!-- Question 4 -->
  <div class="question">
    <p><b>4.</b> What happens when you use <code>const_cast</code> to cast away the constness of an object and then modify it?</p>
    <div class="options"><label><input type="radio" name="q4" value="(A)">(A) The original object will remain unchanged.</label></div>
    <div class="options"><label><input type="radio" name="q4" value="(B)">(B) The object will be modified without any issue.</label></div>
    <div class="options"><label><input type="radio" name="q4" value="(C)">(C) An exception will be thrown.</label></div>
    <div class="options"><label><input type="radio" name="q4" value="(D)">(D) The behavior is undefined if the object was originally declared as <code>const</code>.</label></div>
  <div class="answer" data-question="q4"></div> <!-- Placeholder for answer --></div>

  <!-- Question 36 -->
  <div class="question">
    <p><b>5.</b> Which of the following reasons is NOT motivation behind unit testing?</p>
    <div class="options"><label><input type="radio" name="q36" value="(A)">(A) Unit testing builds trust in our code, improving our confidence that our changes aren&apos;t breaking old code</label></div>
    <div class="options"><label><input type="radio" name="q36" value="(B)">(B) Unit testing provides performance benchmarks of how our code might perform out in the real world</label></div>
    <div class="options"><label><input type="radio" name="q36" value="(C)">(C) If our code has a bug, unit tests can help us pinpoint where the bug is -- or is not</label></div>
    <div class="options"><label><input type="radio" name="q36" value="(D)">(D) Unit testing makes us think about our API design and the accessibility of our functions and classes</label></div>
    <div class="options"><label><input type="radio" name="q36" value="(E)">(E) Unit tests provide a solid foundation of reliability so we can create higher level tests (e.g., integration tests) with more confidence</label></div>
  <div class="answer" data-question="q36"></div> <!-- Placeholder for answer --></div>

  <!-- Question 14 -->
  <div class="question">
    <p><b>6.</b> How can you reset a <code>unique_ptr</code> to release its ownership and make it point to null?</p>
    <div class="options"><label><input type="radio" name="q14" value="(A)">(A) It cannot be reset once assigned.</label></div>
    <div class="options"><label><input type="radio" name="q14" value="(B)">(B) Using the <code>reset()</code> member function.</label></div>
    <div class="options"><label><input type="radio" name="q14" value="(C)">(C) Assigning it a new value using new.</label></div>
    <div class="options"><label><input type="radio" name="q14" value="(D)">(D) By copying it to another <code>unique_ptr</code>.</label></div>
  <div class="answer" data-question="q14"></div> <!-- Placeholder for answer --></div>

  <!-- Question 38 -->
  <div class="question">
    <p><b>7.</b> In Test-Driven Development (TDD), what step is NOT done before the actual feature implementation?</p>
    <div class="options"><label><input type="radio" name="q38" value="(A)">(A) Designing the API</label></div>
    <div class="options"><label><input type="radio" name="q38" value="(B)">(B) Verifying the test suite with stakeholders, system engineer, or rest of the team, if applicable</label></div>
    <div class="options"><label><input type="radio" name="q38" value="(C)">(C) Writing the skeleton of required classes for the feature (e.g., empty methods)</label></div>
    <div class="options"><label><input type="radio" name="q38" value="(D)">(D) Writing tests that compile but fail</label></div>
    <div class="options"><label><input type="radio" name="q38" value="(E)">(E) All of the above are done before feature implementation in TDD</label></div>
  <div class="answer" data-question="q38"></div> <!-- Placeholder for answer --></div>

  <!-- Question 27 -->
  <div class="question">
    <p><b>8.</b> If you trigger undefined behavior by writing outside the bounds of an array, which of the following results is possible according to the C++ standard?</p>
    <div class="options"><label><input type="radio" name="q27" value="(A)">(A) Memory is corrupted.</label></div>
    <div class="options"><label><input type="radio" name="q27" value="(B)">(B) Your computer shuts down.</label></div>
    <div class="options"><label><input type="radio" name="q27" value="(C)">(C) A segmentation fault occurs.</label></div>
    <div class="options"><label><input type="radio" name="q27" value="(D)">(D) An exception is triggered.</label></div>
    <div class="options"><label><input type="radio" name="q27" value="(E)">(E) Any of the above are technically allowed.</label></div>
  <div class="answer" data-question="q27"></div> <!-- Placeholder for answer --></div>

  <!-- Question 29 -->
  <div class="question">
    <p><b>9.</b> If you successfully compile your code, why might you still need to worry about syntax errors with this code?</p>
    <div class="options"><label><input type="radio" name="q29" value="(A)">(A) Syntax errors do not always cause compilation to halt.</label></div>
    <div class="options"><label><input type="radio" name="q29" value="(B)">(B) You don&apos;t -- once you get your code to compile, only other types of errors can be an issue.</label></div>
    <div class="options"><label><input type="radio" name="q29" value="(C)">(C) Syntax errors can be non-deterministic and as such may give you problems on future compilations.</label></div>
    <div class="options"><label><input type="radio" name="q29" value="(D)">(D) Syntax errors may arise at run time.</label></div>
    <div class="options"><label><input type="radio" name="q29" value="(E)">(E) Different compilers or different platforms may trigger syntax errors on compilation.</label></div>
  <div class="answer" data-question="q29"></div> <!-- Placeholder for answer --></div>

  <!-- Question 35 -->
  <div class="question">
    <p><b>10.</b> Which of the following is NOT a key advantage of trace logging (i.e., frequently printing program state to a file) over breakpoint debugging?</p>
    <div class="options"><label><input type="radio" name="q35" value="(A)">(A) Comparing trace logs can identify where non-fatal differences start appearing between runs, thus helping to locate non-deterministic defects.</label></div>
    <div class="options"><label><input type="radio" name="q35" value="(B)">(B) You can use pattern extrapolation on trace logs to predict where future defects will occur.</label></div>
    <div class="options"><label><input type="radio" name="q35" value="(C)">(C) Trace logging allows for post-mortem analysis without halting program execution.</label></div>
    <div class="options"><label><input type="radio" name="q35" value="(D)">(D) Trace logging allows easier automation of bug detection by comparing outputs under a range of conditions without continuous human involvement.</label></div>
  <div class="answer" data-question="q35"></div> <!-- Placeholder for answer --></div>

  <hr><p>
  Click <b>Check Answers</b> to identify any errors and try again.  Click <b>Show Answers</b> if you also want to know which answer is the correct one.
  </p>
  <button type="button" id="checkAnswersBtn">Check Answers</button>
  <button type="button" id="showAnswersBtn">Show Answers</button>
</form>
<div id="results"></div>
<script src="quiz_3_sample_B.js"></script>
</body>
</html>
