<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiple Choice Quiz</title>
  <link rel="stylesheet" href="quiz_2_sample_C.css">
</head>
<body>

<form id="quizForm">
  <h1>Multiple Choice Quiz</h1>

  <!-- Question 33 -->
  <div class="question">
    <p><b>1.</b> According to the core guidelines, where should you set the default values for member variables in a class?</p>
    <div class="options"><label><input type="radio" name="q33" value="(A)">(A) In the class definition where you declare each variable</label></div>
    <div class="options"><label><input type="radio" name="q33" value="(B)">(B) You should never use default values for variables</label></div>
    <div class="options"><label><input type="radio" name="q33" value="(C)">(C) In the body of each constructor</label></div>
    <div class="options"><label><input type="radio" name="q33" value="(D)">(D) In the initializer list for every constructor definition</label></div>
  <div class="answer" data-question="q33"></div> <!-- Placeholder for answer --></div>

  <!-- Question 37 -->
  <div class="question">
    <p><b>2.</b> According to the core guidelines, what is a good technique to reduce the number of parameters to a function?</p>
    <div class="options"><label><input type="radio" name="q37" value="(A)">(A) Build a class around the function where you can pass in the arguments sequentially</label></div>
    <div class="options"><label><input type="radio" name="q37" value="(B)">(B) Split the function into multiple smaller functions, each taking a subset of the original parameters</label></div>
    <div class="options"><label><input type="radio" name="q37" value="(C)">(C) Use abstractions to combine inputs, such as a <code>Point</code> class rather than separate x&apos;s and y&apos;s</label></div>
    <div class="options"><label><input type="radio" name="q37" value="(D)">(D) Rely on default argument values for most of the function parameters</label></div>
    <div class="options"><label><input type="radio" name="q37" value="(E)">(E) Utilize global variables to store commonly used parameters</label></div>
    <div class="options"><label><input type="radio" name="q37" value="(F)">(F) Use <code>std::pair</code> to arbitrarily group pairs of neighboring parameters</label></div>
  <div class="answer" data-question="q37"></div> <!-- Placeholder for answer --></div>

  <!-- Question 32 -->
  <div class="question">
    <p><b>3.</b> How do you speed up your compilation using CPU architecture-specific optimizations?</p>
    <div class="options"><label><input type="radio" name="q32" value="(A)">(A) This is automatic when you use any of the -O optimization flags</label></div>
    <div class="options"><label><input type="radio" name="q32" value="(B)">(B) You can specify the architecture with the <code>-march</code> flag, or <code>-march=native</code> to set it up automatically</label></div>
    <div class="options"><label><input type="radio" name="q32" value="(C)">(C) You can use the <code>-Oarch</code> flag, though you must also include a separate flag for optimization level</label></div>
    <div class="options"><label><input type="radio" name="q32" value="(D)">(D) You must use the -O3 optimization flag</label></div>
    <div class="options"><label><input type="radio" name="q32" value="(E)">(E) Compilation is always specific to a given architecture and cannot be modified</label></div>
  <div class="answer" data-question="q32"></div> <!-- Placeholder for answer --></div>

  <!-- Question 40 -->
  <div class="question">
    <p><b>4.</b> Which of the following is NOT a difference between <code>enum</code> and <code>enum class</code>?</p>
    <div class="options"><label><input type="radio" name="q40" value="(A)">(A) <code>enum class</code> values are only available in the provided class enum namespace, but regular <code>enum</code> values are available outside of the enum namespace</label></div>
    <div class="options"><label><input type="radio" name="q40" value="(B)">(B) <code>enum</code> allows you to specify the starting value, while <code>enum class</code> always starts with zero.</label></div>
    <div class="options"><label><input type="radio" name="q40" value="(C)">(C) <code>enum class</code> allows you to be represented internally as a type other than <code>int</code>, but regular <code>enum</code> is always an <code>int</code> under the hood</label></div>
    <div class="options"><label><input type="radio" name="q40" value="(D)">(D) <code>enum</code> values automatically convert to <code>int</code>, but <code>enum class</code> must be cast to <code>int</code></label></div>
  <div class="answer" data-question="q40"></div> <!-- Placeholder for answer --></div>

  <!-- Question 15 -->
  <div class="question">
    <p><b>5.</b> When should you use the <code>override</code> keyword?</p>
    <div class="options"><label><input type="radio" name="q15" value="(A)">(A) When you want to ensure that a derived function pairs with a virtual function in the base class</label></div>
    <div class="options"><label><input type="radio" name="q15" value="(B)">(B) Whenever you have multiple functions with the same name and want to ensure that they can each be called</label></div>
    <div class="options"><label><input type="radio" name="q15" value="(C)">(C) When you want ensure consistency in a function&apos;s return value and need to override it into a specified range</label></div>
    <div class="options"><label><input type="radio" name="q15" value="(D)">(D) When you want to replace an old definition of a function with a new one</label></div>
  <div class="answer" data-question="q15"></div> <!-- Placeholder for answer --></div>

  <!-- Question 11 -->
  <div class="question">
    <p><b>6.</b> We should always mark a member function as const if it doesn&apos;t change the objects value. Which of the following is NOT a reason for this?</p>
    <div class="options"><label><input type="radio" name="q11" value="(A)">(A) So that the compiler creates an error if we accidentally change the object when we are not expecting to</label></div>
    <div class="options"><label><input type="radio" name="q11" value="(B)">(B) So that the member function can be called on const versions of the associated object</label></div>
    <div class="options"><label><input type="radio" name="q11" value="(C)">(C) It will allow the function to be run in derived versions of this class. </label></div>
    <div class="options"><label><input type="radio" name="q11" value="(D)">(D) So that the compiler might be able to optimize the code more effectively</label></div>
  <div class="answer" data-question="q11"></div> <!-- Placeholder for answer --></div>

  <!-- Question 27 -->
  <div class="question">
    <p><b>7.</b> If two variables are defined as <code>const int * x</code> and <code>int const * y</code>, what is the difference in their types?</p>
    <div class="options"><label><input type="radio" name="q27" value="(A)">(A) There is no difference; they are the same</label></div>
    <div class="options"><label><input type="radio" name="q27" value="(B)">(B) Only the variable <code>x</code> can change which memory position it points to; only <code>y</code> can change the value stored at memory position where it points</label></div>
    <div class="options"><label><input type="radio" name="q27" value="(C)">(C) The variable <code>x</code> cannot be set to <code>nullptr</code>, but <code>y</code> can</label></div>
    <div class="options"><label><input type="radio" name="q27" value="(D)">(D) The variable <code>x</code> can point to both const and non-const integers, while <code>y</code> can only point to const integers</label></div>
    <div class="options"><label><input type="radio" name="q27" value="(E)">(E) Only the variable <code>x</code> can change the value stored at memory position where it points; only <code>y</code> can change which memory position it points to</label></div>
  <div class="answer" data-question="q27"></div> <!-- Placeholder for answer --></div>

  <!-- Question 22 -->
  <div class="question">
    <p><b>8.</b> What is the difference between default initialization of a variable and value initialization?</p>
    <div class="options"><label><input type="radio" name="q22" value="(A)">(A) There is no difference; they are the same</label></div>
    <div class="options"><label><input type="radio" name="q22" value="(B)">(B) Default initialization leaves user-defined classes uninitialized, while value initialization runs their constructor</label></div>
    <div class="options"><label><input type="radio" name="q22" value="(C)">(C) Default initialization leaves built-in types uninitialized, while value initialization initializes them to zero</label></div>
    <div class="options"><label><input type="radio" name="q22" value="(D)">(D) Default initialization always initializes the bytes of any variable to all zeros, while value initialization is customizable</label></div>
  <div class="answer" data-question="q22"></div> <!-- Placeholder for answer --></div>

  <!-- Question 24 -->
  <div class="question">
    <p><b>9.</b> What is the advantage of using <code>std::make_unique</code> or <code>std::make_shared</code> over constructing your unique/shared pointers directly?</p>
    <div class="options"><label><input type="radio" name="q24" value="(A)">(A) It simplifies the allocation process, passing arguments straight through to the constructor</label></div>
    <div class="options"><label><input type="radio" name="q24" value="(B)">(B) It sets the output type to be a smart pointer so that deletion will be handled properly</label></div>
    <div class="options"><label><input type="radio" name="q24" value="(C)">(C) It provides a performance improvement</label></div>
    <div class="options"><label><input type="radio" name="q24" value="(D)">(D) It makes it easier to swap the underlying pointer</label></div>
  <div class="answer" data-question="q24"></div> <!-- Placeholder for answer --></div>

  <!-- Question 49 -->
  <div class="question">
    <p><b>10.</b> Andrei Alexandrescu&apos;s short string optimization is often given as an example of really clever problem solving. <br>
What did he gain when he swapped string size for _remaining_ string size?</p>
    <div class="options"><label><input type="radio" name="q49" value="(A)">(A) Remaining size is guaranteed to never be zero</label></div>
    <div class="options"><label><input type="radio" name="q49" value="(B)">(B) For a full string, the size was also used as the null terminator</label></div>
    <div class="options"><label><input type="radio" name="q49" value="(C)">(C) It required fewer bits to store the remaining size as compared to full size</label></div>
    <div class="options"><label><input type="radio" name="q49" value="(D)">(D) This swap ensured that the strings would always be able to fit into cache</label></div>
    <div class="options"><label><input type="radio" name="q49" value="(E)">(E) All of the above</label></div>
  <div class="answer" data-question="q49"></div> <!-- Placeholder for answer --></div>

  <hr><p>
  Click <b>Check Answers</b> to identify any errors and try again.  Click <b>Show Answers</b> if you also want to know which answer is the correct one.
  </p>
  <button type="button" id="checkAnswersBtn">Check Answers</button>
  <button type="button" id="showAnswersBtn">Show Answers</button>
</form>
<div id="results"></div>
<script src="quiz_2_sample_C.js"></script>
</body>
</html>
